import { useSearchParams, useNavigate } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import Papa from "papaparse";
import { Chart, registerables, ChartConfiguration } from 'chart.js';
import 'chartjs-adapter-date-fns';
// Optional: Locale f√ºr Diagramm-Datumsformatierung
// import { de } from 'date-fns/locale';
import type { ChartItem, ChartTypeRegistry, Point, BubbleDataPoint } from "chart.js/auto";
import DatePicker from "react-datepicker";
import { detect } from 'detect-browser';

import "react-datepicker/dist/react-datepicker.css";
import "../index.css"; // Globale Styles und Tailwind
// import "../styles/StatistikToken.css"; // Spezifische Styles, falls noch ben√∂tigt

Chart.register(...registerables);

const extractExtraUAInfo = (uaString: string): { arch: string; engine: string } => {
    let arch = "N/A";
    let engine = "N/A";
    if (!uaString || uaString === "Unbekannt" || uaString === "Detect Failed") return { arch, engine };

    if (/x64|win64|amd64|x86_64/i.test(uaString)) arch = "x64";
    else if (/wow64/i.test(uaString)) arch = "WOW64"; // 32bit on 64bit Windows
    else if (/arm/i.test(uaString)) arch = "ARM";
    else if (/i[3-6]86/i.test(uaString) && !/x86_64/i.test(uaString)) arch = "x86";
    else if (/Macintosh|Mac OS X/i.test(uaString) && !/arm/i.test(uaString) && !uaString.toLowerCase().includes("iphone") && !uaString.toLowerCase().includes("ipad")) arch = "Mac Intel";
    else if (/Macintosh|Mac OS X/i.test(uaString) && /arm/i.test(uaString)) arch = "Mac ARM";

    // Engine-Erkennung verfeinert
    if (/Edg\//i.test(uaString)) engine = "Blink"; // Edge (Chromium-basiert)
    else if (/Chrome\//i.test(uaString) && /AppleWebKit/i.test(uaString) && !/OPR\//i.test(uaString)) engine = "Blink"; // Chrome
    else if (/OPR\//i.test(uaString) || /Opera/i.test(uaString)) engine = "Blink"; // Opera ist auch Blink
    else if (/Firefox\//i.test(uaString) && /Gecko\//i.test(uaString) && !/like Gecko/i.test(uaString) && !/Seamonkey\//i.test(uaString)) engine = "Gecko"; // Firefox
    else if (/Safari\//i.test(uaString) && /AppleWebKit/i.test(uaString) && !/Chrome\//i.test(uaString) && !/Edg\//i.test(uaString)) engine = "WebKit"; // Safari
    else if (/Trident/i.test(uaString)) engine = "Trident"; // Internet Explorer
    else if (/Presto/i.test(uaString)) engine = "Presto"; // √Ñlteres Opera
    else if (/AppleWebKit/i.test(uaString)) engine = "WebKit"; // Generischer Fallback f√ºr WebKit-basierte Browser
    else if (/Gecko\//i.test(uaString) && !/like Gecko/i.test(uaString)) engine = "Gecko"; // Generischer Fallback f√ºr Gecko
    
    return { arch, engine };
};

export default function StatistikToken() {
  const [params] = useSearchParams();
  const navigate = useNavigate();
  const [zugelassen, setZugelassen] = useState(false);
  const [rows, setRows] = useState<string[][]>([]);
  const [visitCountsPerDayState, setVisitCountsPerDayState] = useState<Record<string, number>>({});
  const [sortConfig, setSortConfig] = useState<{ index: number; direction: "asc" | "desc" } | null>({ index: 0, direction: "desc" });
  const [filterSystem, setFilterSystem] = useState("");
  const [filterArch, setFilterArch] = useState("");
  const [filterBrowser, setFilterBrowser] = useState("");
  const [filterReferer, setFilterReferer] = useState("");
  const [dateFrom, setDateFrom] = useState<Date | null>(null);
  const [dateTo, setDateTo] = useState<Date | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const pageSize = 50;
  const [statistikChartInstance, setStatistikChartInstance] = useState<Chart | null>(null);
  const [fetchError, setFetchError] = useState<string | null>(null);

  const tableHeaders = ["Zeit", "IP", "System", "Architektur", "Engine", "Browser", "Version", "Referer"];
  const columnIndices = { Zeit: 0, IP: 1, System: 2, Architektur: 3, Engine: 4, Browser: 5, Version: 6, Referer: 7 };

  useEffect(() => {
    const token = params.get("token");
    if (token === import.meta.env.VITE_SECRET_TOKEN) setZugelassen(true);
    else navigate("/");
  }, [params, navigate]);

  // Daten laden und parsen
  useEffect(() => {
    if (!zugelassen) return;
    setFetchError(null);
    
    fetch("/server_api/visits.csv")
      .then(res => res.ok ? res.text() : Promise.reject(new Error(`CSV nicht gefunden (${res.status})`)))
      .then(text => {
        const { data, errors: parseErrors } = Papa.parse<string[]>(text, {
          delimiter: ";", skipEmptyLines: true, quoteChar: '"', header: false,
        });

        if (parseErrors.length > 0 && parseErrors.some(e => e.code !== 'TooFewFields' && e.code !== 'TooManyFields' && e.code !== 'UndetectableDelimiter')) {
            console.error("Kritische CSV Parse-Fehler:", parseErrors);
            setFetchError(`Krit. CSV Fehler (Zeile ${parseErrors[0].row}: ${parseErrors[0].message})`);
            setRows([]); setVisitCountsPerDayState({}); return;
        }
        
        const rowsOnly = data && data.length > 1 ? data.slice(1) : []; // Erste Zeile ist Header
        if (!rowsOnly || rowsOnly.length === 0) {
            setRows([]); setVisitCountsPerDayState({}); return;
        }

        const localValidRows: string[][] = [];
        const localVisitCounts: Record<string, number> = {};

        for (const parts of rowsOnly) {
          if (!parts || parts.length < 4) { continue; } // Erwarte Zeit;IP;"UA";"Referer"
          const timestamp = parts[0]?.trim() || "Unbekannt";
          const ip = parts[1]?.trim() || "Unbekannt";
          const rawUserAgent = parts[2]?.trim() || "Unbekannt"; 
          const referer = parts[3]?.trim() || "N/A";       
          
          const browserInfo = detect(rawUserAgent);
          const extraInfo = extractExtraUAInfo(rawUserAgent);
          let system = "Unbekannt", browser = "Unbekannt", version = "Unbekannt", arch = extraInfo.arch, engine = extraInfo.engine, isBot = false;

          if (browserInfo) {
            system = browserInfo.os || system;
            version = browserInfo.version || version;
            if (browserInfo.type === 'bot') {
                browser = `Bot: ${browserInfo.name || 'Unknown'}`; isBot = true; version = browserInfo.version || 'N/A'; 
                 if(system === "Unbekannt" && browserInfo.name) system = `${browserInfo.name} Bot`;
                 if (engine === "N/A" && browserInfo.name) engine = browserInfo.name;
            } else { browser = browserInfo.name || "Unbekannt"; }
            const majorVersion = version.split('.')[0];
            if(browser !== "Unbekannt" && majorVersion && !isBot && !isNaN(Number(majorVersion))) { browser = `${browser} ${majorVersion}`; }
            else if (isBot && browser === "Bot: Unknown") { const botMatch = rawUserAgent.match(/([a-zA-Z0-9]+[bB]ot)/); if (botMatch) browser = `Bot: ${botMatch[1]}`; }
            if (system.toLowerCase().includes('android') && version !== "Unbekannt" && !isBot) {
                 const androidVersionMatch = rawUserAgent.match(/Android (\d+(\.\d+)?)/i);
                 if (androidVersionMatch) { system = `Android ${androidVersionMatch[1]}`; } 
                 else if (version.split('.')[0] && !isNaN(Number(version.split('.')[0]))) { system = `Android ${version.split('.')[0]}`; }
            }
          } else {
             if (rawUserAgent !== "Unbekannt" && rawUserAgent !== "") { console.warn(`detect-browser returned null for UA: "${rawUserAgent}"`); }
             system = system === "Unbekannt" ? "Detect Failed" : system; browser = browser === "Unbekannt" ? "Detect Failed" : browser; version = version === "Unbekannt" ? "N/A" : version;
          }
          localValidRows.push([timestamp, ip, system, arch, engine, browser, version, referer]);
          const day = timestamp.split(" ")[0];
          if (day && day.match(/^\d{4}-\d{2}-\d{2}$/)) { localVisitCounts[day] = (localVisitCounts[day] || 0) + 1; }
        }
        setRows(localValidRows);
        setVisitCountsPerDayState(localVisitCounts);
      })
      .catch(error => { 
        console.error("Fehler beim Laden/Verarbeiten von visits.csv:", error);
        setFetchError(error.message || "Unbekannter Fehler beim Datenladen.");
        setRows([]); setVisitCountsPerDayState({});
      });
  }, [zugelassen, navigate]);

  // useEffect f√ºr Chart-Erstellung/-Update
  useEffect(() => {
    if (!zugelassen) {
      if (statistikChartInstance) { statistikChartInstance.destroy(); setStatistikChartInstance(null); }
      return;
    }
    const counts = visitCountsPerDayState;
    const ctx = document.getElementById("statistikChart") as HTMLCanvasElement | null;

    if (statistikChartInstance) { statistikChartInstance.destroy(); }

    if (ctx && Object.keys(counts).length > 0) {
      const sortedDays = Object.keys(counts).sort((a,b) => new Date(a).getTime() - new Date(b).getTime());
      const sortedDataPoints = sortedDays.map(day => counts[day]);
      const maxCount = Math.max(...sortedDataPoints, 0);
      try {
          const chartConfig: ChartConfiguration<keyof ChartTypeRegistry, number[], string> = { // Angepasste Typen f√ºr data
            type: "bar",
            data: { labels: sortedDays, datasets: [{ label: "Besuche pro Tag", data: sortedDataPoints, backgroundColor: "rgba(75,192,192,0.6)", borderColor: "rgba(75,192,192,1)", borderWidth: 1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, suggestedMax: maxCount > 0 ? maxCount + Math.ceil(maxCount * 0.1) + 1 : 5, ticks: { stepSize: maxCount > 10 ? undefined : 1, precision: 0 } }, x: { type: 'time', time: { unit: 'day', tooltipFormat: 'dd.MM.yyyy', displayFormats: { day: 'dd.MM.yy' } }, /* adapters: { date: { locale: de } } */ } }, plugins: { tooltip: { mode: 'index', intersect: false, } } }
          };
          // @ts-ignore ChartItem ist korrekt f√ºr ctx, aber Chartjs erwartet HTMLCanvasElement | string
          const newChart = new Chart(ctx, chartConfig); 
          setStatistikChartInstance(newChart);
      } catch (chartError) { console.error("Chart Erstellungsfehler:", chartError); setFetchError("Fehler Diagramm: " + (chartError as Error).message); setStatistikChartInstance(null);  }
    } else if (ctx) {
      const context = ctx.getContext('2d');
      if (context) { context.clearRect(0,0,ctx.width, ctx.height); context.font = "16px Arial"; context.textAlign = "center"; context.fillText("Keine Diagrammdaten", ctx.width / 2, ctx.height / 2); }
      setStatistikChartInstance(null); 
    } else { setStatistikChartInstance(null); }
  }, [visitCountsPerDayState, zugelassen]);


  const processed = useMemo(() => {
    let out = [...rows];
    // Filter
    if (filterSystem) out = out.filter(r => r[columnIndices.System]?.toLowerCase().includes(filterSystem.toLowerCase()));
    if (filterArch && filterArch !== "N/A") out = out.filter(r => r[columnIndices.Architektur]?.toLowerCase() === filterArch.toLowerCase());
    if (filterBrowser) out = out.filter(r => r[columnIndices.Browser]?.toLowerCase().includes(filterBrowser.toLowerCase()));
    if (filterReferer) out = out.filter(r => r[columnIndices.Referer]?.toLowerCase().includes(filterReferer.toLowerCase()));
    // Datumsfilter korrigiert
    if (dateFrom) {
        const startOfDayFrom = new Date(dateFrom); startOfDayFrom.setHours(0, 0, 0, 0); 
        const fromTime = startOfDayFrom.getTime();
        out = out.filter(r => { try { const entryDate = new Date(r[columnIndices.Zeit].replace(" ", "T") + "Z"); return entryDate.getTime() >= fromTime; } catch { return false; } });
    }
    if (dateTo) { 
        const endOfDayTo = new Date(dateTo); endOfDayTo.setHours(23, 59, 59, 999); 
        const toTime = endOfDayTo.getTime();
        out = out.filter(r => { try { const entryDate = new Date(r[columnIndices.Zeit].replace(" ", "T") + "Z"); return entryDate.getTime() <= toTime; } catch { return false; } });
    }
    // Sortierung
    if (sortConfig) { 
        out.sort((a, b) => { 
            const index = sortConfig.index; 
            if (index === columnIndices.Zeit) { try { const dateA = new Date(a[0].replace(" ", "T") + "Z").getTime(); const dateB = new Date(b[0].replace(" ", "T") + "Z").getTime(); if (isNaN(dateA) || isNaN(dateB)) return 0; return sortConfig.direction === "asc" ? dateA - dateB : dateB - dateA; } catch { return 0; } } 
            const valA = a[index] || ""; const valB = b[index] || ""; return sortConfig.direction === "asc" ? valA.localeCompare(valB) : valB.localeCompare(valA); 
        }); 
    }
    return out;
  }, [rows, filterSystem, filterArch, filterBrowser, filterReferer, dateFrom, dateTo, sortConfig]);

  useEffect(() => {
    if (rows.length > 0) { setCurrentPage(1); }
  }, [processed, rows.length]); // rows.length hinzugef√ºgt, um auch bei leerem Filter-Ergebnis (aber existierenden rows) zur√ºckzusetzen

  const pageCount = Math.ceil(processed.length / pageSize);
  useEffect(() => {
       const newTotalPages = Math.max(1, Math.ceil(processed.length / pageSize)); // Mindestens 1 Seite
       if (currentPage > newTotalPages ) { setCurrentPage(newTotalPages); }
   }, [processed.length, pageSize, currentPage]);

  const pageRows = useMemo(() => {
    const safeCurrentPage = Math.max(1, Math.min(currentPage, pageCount || 1));
    return processed.slice((safeCurrentPage - 1) * pageSize, safeCurrentPage * pageSize);
  }, [processed, currentPage, pageSize, pageCount]);

  if (!zugelassen) return <div className="p-4 text-red-600">‚õî Zugriff verweigert</div>;
  const pageTitle = "üìä Besucherstatistik";

  return (
    <>
      {/* Club-Header optional, hier entfernt, da im Druck st√∂rt */}
      {/* <header className="header-bar">Schachclub Laufenburg‚ÄØeV.‚ÄØ1969</header> */}
      
      <div className={`p-4 statistik-page-main-content`}>
        <h1 className="text-2xl font-bold mb-4">{pageTitle}</h1>
        {fetchError && ( <div className="p-4 mb-4 text-red-700 bg-red-100 border border-red-400 rounded" role="alert"> <strong>Fehler:</strong> {fetchError} </div> )}
        
        <div className="flex justify-end gap-4 mb-4 no-print">
          <button onClick={() => { /* CSV Export */ }} className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors">üì• CSV‚ÄëExport</button>
          <button onClick={() => window.print()} className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors">üñ®Ô∏è Drucken</button>
        </div>

        {/* Diagramm-Container - no-print wurde entfernt */}
        <div className="chart-container"><canvas id="statistikChart" /></div>

        <div className="filters no-print">
           <div className="filter-row">
             <select value={filterSystem} onChange={e => setFilterSystem(e.target.value)} aria-label="System filtern"> <option value="">Alle Systeme</option> {[...new Set(rows.map(r => r[columnIndices.System]))].sort().filter(s => s && s !== "Detect Failed" && s !== "UA-ParseErr").map(s => <option key={s} value={s}>{s}</option>)} </select>
             <select value={filterArch} onChange={e => setFilterArch(e.target.value)} aria-label="Architektur filtern"> <option value="">Alle Architekturen</option> {[...new Set(rows.map(r => r[columnIndices.Architektur]))].sort().filter(a => a && a !== 'N/A').map(a => <option key={a} value={a}>{a}</option>)} </select>
             <select value={filterBrowser} onChange={e => setFilterBrowser(e.target.value)} aria-label="Browser filtern"> <option value="">Alle Browser</option> {[...new Set(rows.map(r => r[columnIndices.Browser]))].sort().filter(b => b && b !== "Detect Failed" && b !== "UA-ParseErr").map(b => <option key={b} value={b}>{b}</option>)} </select>
             <input type="text" placeholder="Referer enth√§lt" value={filterReferer} onChange={e => setFilterReferer(e.target.value)} aria-label="Referer filtern" className="border px-2 py-1"/>
           </div>
           <div className="date-range-row">
             <DatePicker selected={dateFrom} onChange={(d: Date | null) => setDateFrom(d)} placeholderText="Von" dateFormat="dd.MM.yyyy" className="border px-2 py-1" isClearable selectsStart startDate={dateFrom} endDate={dateTo} aria-label="Startdatum f√ºr Filter" />
             <DatePicker selected={dateTo} onChange={(d: Date | null) => setDateTo(d)} placeholderText="Bis" dateFormat="dd.MM.yyyy" className="border px-2 py-1" isClearable selectsEnd startDate={dateFrom} endDate={dateTo} minDate={dateFrom} aria-label="Enddatum f√ºr Filter" />
           </div>
        </div>
        <div className="pagination no-print">
           {pageCount > 1 && Array.from({ length: pageCount }, (_, i) => ( <button key={i} onClick={() => setCurrentPage(i + 1)} className={currentPage === i + 1 ? "active" : ""} aria-label={`Gehe zu Seite ${i + 1}`} aria-current={currentPage === i + 1 ? "page" : undefined} >{i + 1}</button> ))}
        </div>
        <div className="table-container no-print no-print-table">
           <table>
             <thead><tr>{tableHeaders.map((col, idx) => ( <th key={col} onClick={() => { setSortConfig(prev => prev && prev.index === idx ? { index: idx, direction: prev.direction === "asc" ? "desc" : "asc" } : { index: idx, direction: "asc" }); }} scope="col" style={{cursor: 'pointer'}} > {col}{sortConfig?.index === idx ? (sortConfig.direction === "asc" ? " ‚ñ≤" : " ‚ñº") : ""} </th> ))}</tr></thead>
             <tbody>
               {pageRows.length === 0
                 ? <tr><td colSpan={tableHeaders.length} className="text-center py-4">Keine Besucherdaten</td></tr>
                 : pageRows.map((row, i, arr) => {
                   let showBorder = false;
                   const isSortedByDate = !sortConfig || sortConfig.index === columnIndices.Zeit;
                   if (isSortedByDate) {
                       const currentDate = row[columnIndices.Zeit]?.split(" ")[0];
                       const prevRowDate = i > 0 ? arr[i-1]?.[columnIndices.Zeit]?.split(" ")[0] : null;
                       if (currentDate && prevRowDate && currentDate !== prevRowDate) {
                           showBorder = true;
                       }
                   }
                   return ( <tr key={(row[columnIndices.Zeit] || `row-${i}`) + "-" + i + currentPage} className={showBorder ? "border-t-4 border-black" : ""}> {row.map((c, j) => <td key={`${j}-${i}`} className={j === columnIndices.Referer ? "referrer" : ""}>{c || "N/A"}</td>)} </tr> );
                 })}
             </tbody>
           </table>
        </div>
        <div className="table-container print-only" id="print-section">
           <table>
             <thead><tr>{tableHeaders.map(col => ( <th key={"print-h-"+col} scope="col">{col}</th> ))}</tr></thead>
             <tbody>
               {processed.length === 0
                 ? <tr><td colSpan={tableHeaders.length} className="text-center py-4">Keine Besucherdaten</td></tr>
                 : processed.map((row, i) => ( <tr key={"print-" + i}> {row.map((c, j) => <td key={"print-cell-" + j + "-" + i}>{c || "N/A"}</td>)} </tr> ))}
             </tbody>
           </table>
        </div>
      </div>
    </>
  );
}